	I wanted to create something that would be difficult, and potentially even tedious to really get to know OpenGL. The bike pump in the scene would require particular attention to the spacing of the objects that make it up to create a realistic looking pump. The automan is a simple shape but it has a multitude of small white spheres on it that made the creation of the full object tedious and time consuming. Otherwise this scene is pretty simple, including a glass of water for a fun changeup of texture and glare when lit and some puzzle boxes. All in creating the simple objects took very little time but creating the complex ones was tedious at best. This scene gave me plenty to work with in terms of material differences and colors as well. The variety of this scene was challenging but entertaining to create in OpenGL. Programming for the creation of textures, materials, and lighting was difficult because the methods that are pre-baked into this program are different from the ones we have used previously. For example the CreateGLTextures method made it so that I had to write each texture into the PrepareScene method instead of calling the method once to bring in all of my textures. Now that I am writing this, maybe I could have just called it a single time instead of instantiating it for each texture. Building in keyboard, mouse, and scrolling functionality was difficult as well as it required me to go through multiple files to look for methods to call/create depending on the built-in functionality. 
For mouse-to-look functionality I had to initialize the reference position on the first movement then calculate the difference between the current and last mouse positions. After that was calculated the method then updated the last known position to the current position. This passes the calculated offsets to the camera's processing method to update the camera view based on the mouse movement. Mouse scroll functionality was much easier. It tracks the offset of the mouse scroll in the y-plane and adjusts speed up as the user scrolls up and slows down when the user scrolls down. Since the keyboard functionality was already built-in all that was needed from me was to bind certain keys to certain events. Using the glfwGetKey method I added Q and E to the mapped keys and set them to move left and right. Changing the scene’s view from perspective to orthographic was a bit trickier than just key binding. The keybinding is the same but clicking the button would alter the viewing matrix in PrepareSceneView with two variations of the camera setup. Using the camera utilizes the full-depth of a computer's input devices.
	To look around the scene like you would move your head you can use the mouse or trackpad. Simply move the mouse left/right/up/down to move the camera in the same direction. This will not change the orientation of the camera but it will allow you to “look around”. To move the camera up and down you can use the Q and E keys respectively. To move the camera left and right you would utilize the A and D keys respectively. Zooming in can be done with the W key, while zooming out can be done with the S key. Scroll up on the tracker pad/mouse to speed up the rate of movement and down to slow it back down again. The O key will change the camera to the orthographic view, and the P key will change it back to the perspective view in which the camera starts up.
	Reusability is essential in modern coding practices. The SetupSceneLights, DefineObjectMaterials, and GetGLTextures are all great examples of modularized coding practices. These will let you take these methods and pull them into a different scene to be used at will as their supporting materials are referenced within their file. SetupSceneLights lets the user define the lighting within that method and call the method once to bring the lighting to life within their scene. DefineObjectMaterials is even more modular! It defines materials to be used within that method and the user can utilize them simply by calling their tag while creating the shape meshes. 
